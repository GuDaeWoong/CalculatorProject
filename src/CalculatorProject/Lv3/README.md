# **LV3_계산기 만들기**


**필수 기능가이드**


### 계산기를 만들어라
- 계산기는 2개의 숫자를 받을 수 있고 사칙연산 될 문자를 받을 수 있다.
- 계산기는 exit을 입력할 때까지 계속해서 값을 받고 연산 결과를 반환한다.


### 1. 양의정수(0 포함)를 입력받기
- Scanner를 사용하여 양의 정수 2개(0포함)를 전달 받을 수 있습니다.
- 양의 정수는 각각 하나씩 전달 받습니다
- 양의 정수는 적합한 타입으로 선언한 변수에 저장합니다.


### 2. 사칙연산 기호(➕,➖,✖️,➗)를 입력받기
- Scanner를 사용하여 사칙연산 기호를 전달 받을 수 있습니다.
- 사칙연산 기호를 적합한 타입의로 선언한 변수에 저장합니다.


### 3. 위에서 입력받은 양의 정수 2개와 사칙연산 기호를 사용하여 연산을 진행한 후 결과 값을 출력하기
- 사칙연산 기호에 맞는 연산자를 사용하여 연산을 진행합니다.
- 입력받은 연산 기호를 구분하기 위해 제어문을 사용합니다.
- 연산 오류가 발생할 경우 해당 오류에 대한 내용을 정제하여 출력합니다.
 - “나눗셈 연산에서 분모(두번째 정수)에 0이 입력될 수 없습니다.“


### 4. 반복문을 사용하되, 반복의 종료를 알려주는 exit 문자열을 입력하기전까지 무한으로 계산을 진행할 수 있도록 소스코드를 수정하기




# **LV2 추가 사항**



### 1. 사칙연산을 수행 후, 결과값 반환 메서드 구현 & 연산 결과를 저장하는 컬렉션 타입 필드를 가진 Calculator 클래스를 생성
- 사칙연산을 수행한 후 결과 값을 반환하는 메서드 구현
- 연산 결과를 저장하는 컬렉션 타입 필드를 가진 Calculator를 생성
- 양의 정수 2개(0 포함)와 연산 기호를 매개변수로 받아 사칙연산(➕,➖,✖️,➗) 기능을 수행한 후 2) 결과 값을 반환하는 메서드와 연산 결과를 저장하는 컬렉션 타입 필드를 가진 Calculator 클래스를 생성합니다.


### 2. Lv 1에서 구현한 App 클래스의 main 메서드에 Calculator 클래스가 활용될 수 있도록 수정
- 연산 수행 역할은 Calculator 클래스가 담당 
- 연산 결과는 Calculator 클래스의 연산 결과를 저장하는 필드에 저장
- 소스 코드 수정 후에도 수정 전의 기능들이 반드시 똑같이 동작해야합니다.


### 3. App 클래스의 main 메서드에서 Calculator 클래스의 연산 결과를 저장하고 있는 컬렉션 필드에 직접 접근하지 못하도록 수정 (캡슐화)
- 간접 접근을 통해 필드에 접근하여 가져올 수 있도록 구현합니다. (Getter 메서드)
- 간접 접근을 통해 필드에 접근하여 수정할 수 있도록 구현합니다. (Setter 메서드)
- 위 요구사항을 모두 구현 했다면 App 클래스의 main 메서드에서 위에서 구현한 메서드를 활용 해봅니다.


### 4. Calculator 클래스에 저장된 연산 결과들 중 가장 먼저 저장된 데이터를 삭제하는 기능을 가진 메서드를 구현한 후 App 클래스의 main 메서드에 삭제 메서드가 활용될 수 있도록 수정




# **LV3 추가 사항**


### 1. 현재 사칙연산 계산기는 (➕,➖,✖️,➗) 이렇게 총 4가지 연산 타입으로 구성되어 있습니다.
- Enum 타입을 활용하여 연산자 타입에 대한 정보를 관리하고 이를 사칙연산 계산기 ArithmeticCalculator 클래스에 활용 해봅니다.


### 2. 실수, 즉 double 타입의 값을 전달 받아도 연산이 수행하도록 만들기
- 키워드 : 제네릭
- 지금까지는 ArithmeticCalculator, 즉 사칙연산 계산기는 양의 정수(0 포함)를 매개변수로 전달받아 연산을 수행

- 피연산자를 여러 타입으로 받을 수 있도록 기능을 확장

	- ArithmeticCalculator 클래스의 연산 메서드(calculate)
	- 위 요구사항을 만족할 수 있도록 ArithmeticCalculator 클래스를 수정합니다. (제네릭)


### 3. 저장된 연산 결과들 중 Scanner로 입력받은 값보다 큰 결과값 들을 출력
- ArithmeticCalculator 클래스에 위 요구사항을 만족하는 조회 메서드를 구현합니다.
- 단, 해당 메서드를 구현할 때 Lambda & Stream을 활용하여 구현합니다. 
-  Java 강의에서 람다 & 스트림을 학습 및 복습 하시고 적용 해보세요!
 - 추가) 람다 & 스트림 학습을 위해 여러 가지 조회 조건들을 추가하여 구현 해보시면 학습에 많은 도움이 되실 수 있습니다.




## ❓ LV2 를 진행하며


### / 연산에서 분모에 0이 입력이 되었을때 result 값을 어떻게 반환해야할까?
calculate 는 연산의 하여 값을 반환하는 메서드이다
"/ 연산에서 분모에 0이 입력될 수 없습니다." 가 끝이아닌 결과 값을 반환하지 않을 수 없다.
이때 return을 사용한다면 연산을 끝낼 수 있다. 하지만 값을 반환하지 않으면 에러가 발생한다.
이때 어떠한 값을 반환해야 문제가 생기지 않을 수 있을지 고민하게 되었다.
이때 고민하게된것이 null이다. 잘못된 값을 쌓이지도 않으면서 반환을 해서 제어를 하면 어떨까 라는 생각을 가지게 되었다.
return null; 을 사용함으로써 연산을 끝내고 null로 반환후 AppLv2에서 null인 경우 처음으로 되돌아가라는
조건을 주면서 continue를 사용하여 해결하였다.
이문제를 해결하긴 하였으나 null은 "객체가 없음"을 나타내는 값이기 때문에
null을 사용하는것이 좋지 않다는 말을 듣게되었다.
이를 해결하기 위한 더 좋은 방법이 없을까 라는 생각을 하게 되었고 다른방법들을 탐색하였다.
특정 오류 값 을 야기하는 방법이 있었다. 바로 Integer.MAX_VALUE + 1 이다. long 타입이 표현할 수 있는 매우 큰 값중 하나이다. 이를 오류 상황을 나타내는 특정 값 을 약속하고 사용한다는 것 이다. 이렇게 하면 메서드 호출자는 반환된 값이 오류임을 알 수 있다.
AppLv2 클래스에서 Integer.MAX_VALUE 보다 큰지 확인하여 오류 상황을 감지하여  해결하는 방안이 있다는 것을 깨우쳤다.


### 3-3 "저장된 연산 결과들 중 Scanner로 입력받은 값보다 큰 결과값 들을 출력" 라는 문제를 어떻게 접근해야 하나 고민해보았다. 첫번째 숫자나 두번째 숫자를 기준으로 해야할지 언급이 없었다.
 그래서 생각했던게 계산해서 나온값을 기준으로 비교해서 반환해야 하지않나 라는 생각이 들었다. 이번 문제를 통해 Java Stream API의 stream(), filter(), map(), 그리고 toList() 메서드를 활용하였다. 특히 람다 표현식을 사용해서 필터링 조건을 간결하게 완료하였다.